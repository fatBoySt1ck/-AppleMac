#Requires AutoHotkey v2.0
#SingleInstance Force
#Warn
Persistent

; File: RobloxMacro_CleanGUI_NoCBH.ahk
; Clean GUI, NO CBH/CBHP, compact layout that fits on screen

CoordMode "Mouse", "Screen"
SetMouseDelay(-1)

INI_PATH := A_ScriptDir "\RobloxMacroSettings.ini"
PI := 3.14159265358979

DEFAULT := Map(
    "privateServerLink", "https://www.roblox.com/share?code=843fe2cca5580742b1dbff7fdf8d07bc&type=Server",
    "robloxExe",         "RobloxPlayerBeta.exe",
    "browserExe",        "brave.exe",
    "rejoinIntervalMin", 60,
    "preRelaunchSec",    15,
    "postLinkWaitSec",   9,
    "detectTimeoutSec",  15,
    "browserGraceSec",   3,
    "autoRejoinEnabled", 1,
    "showCountdownTip",  1,
    "m1_startDelaySec",  20,
    "m1_tickMs",         25,
    "m1_moveDurationSec",25,
    "m1_pause1Sec",      2,
    "m1_pause2Sec",      2,
    "m1_loopWaitSec",    5,
    "m1_LeftX",          200,
    "m1_RightX",         1200,
    "m1_CenterY",        490,
    "m1_Amplitude",      150,
    "m1_Speed",          15,
    "m1_key1",           "o",
    "m1_key1HoldMs",     320,
    "m1_key2",           "Up",
    "m1_key2HoldMs",     20,
    "m1_postKey2DelayMs",300,
    "m1_afterPrepKey",   "3",
    "m1_keyEsc",         "Esc",
    "m1_keyReset",       "r",
    "m1_keyEnter",       "Enter",
    "m1_showBox",        1,
    "m1_boxThickness",   3,
    "m1_boxColor",       "Red",
    "m1_showPath",       1,
    "m1_pathColor",      "Yellow",
    "m1_pathStepPx",     28,
    "m1_pathDotSize",    2,
    "m1_cursorDotColor", "Aqua",
    "m1_cursorDotSize",  6,
    "hk_m1",      "F6",
    "hk_rejoin",  "F8",
    "hk_overlay", "F9"
)

state := Map(
    "m1_running", false,
    "m1_step", 0,
    "m1_stepStart", 0,
    "m1_sub", 0,
    "m1_topUp", 0,
    "m1_mouseX", DEFAULT["m1_LeftX"],
    "m1_isDown", false,
    "m1_lastX", 0,
    "m1_lastY", 0,
    "m1_lastDownRefresh", 0,
    "nextRejoinTick", A_TickCount + (DEFAULT["rejoinIntervalMin"] * 60000)
)

cfg := LoadSettings()

global overlayEnabled := true
global overlayX := 20, overlayY := 60
global overlayW := 560, overlayH := 74
global overlayOpacity := 200
global overlayFontSize := 12
global overlayTextColor := "Lime"
global overlayBackColor := "Black"
global overlayShowSteps := true
global overlayShowActive := true
global overlayPadding := 12
global overlayRadius := 14
global overlayCompact := false
global overlayTheme := 0
global _ov := 0

global _m1bxT := 0, _m1bxB := 0, _m1bxL := 0, _m1bxR := 0
global _m1Dots := []
global _m1CurDot := 0

global _rbxHwnd := 0
global _lastFocusTick := 0

FindRobloxHwnd() {
    global cfg
    hwnd := WinExist("ahk_exe " cfg["robloxExe"])
    if (!hwnd)
        hwnd := WinExist("Roblox")
    return hwnd ? hwnd : 0
}
EnsureRobloxFocus(msCooldown := 300, reassertDown := false) {
    global _rbxHwnd, _lastFocusTick, state
    if (A_TickCount - _lastFocusTick < msCooldown)
        return
    if (!_rbxHwnd || !WinExist("ahk_id " _rbxHwnd))
        _rbxHwnd := FindRobloxHwnd()
    activated := false
    if (_rbxHwnd && !WinActive("ahk_id " _rbxHwnd)) {
        WinActivate("ahk_id " _rbxHwnd)
        activated := true
    }
    _lastFocusTick := A_TickCount
    if (reassertDown && activated) {
        if (state["m1_running"] && state["m1_isDown"])
            LMB_Down()
    }
}

GetBrowserPresets() => ["brave.exe","chrome.exe","msedge.exe","firefox.exe","opera.exe","vivaldi.exe"]

LoadServerPresets() {
    global INI_PATH, DEFAULT
    arr := []
    if FileExist(INI_PATH) {
        loop 10 {
            v := ""
            try {
                v := IniRead(INI_PATH, "servers", A_Index, "")
            } catch {
                v := ""
            }
            if (v != "")
                arr.Push(v)
        }
    }
    if (arr.Length = 0)
        arr.Push(DEFAULT["privateServerLink"])
    return arr
}
SaveServerPreset(link) {
    global INI_PATH, ui
    link := Trim(link)
    if (link = "")
        return
    list := LoadServerPresets()
    nlist := []
    seen := Map()
    nlist.Push(link), seen[link] := true
    for _, s in list {
        s := Trim(s)
        if (s != "" && !seen.Has(s)) {
            nlist.Push(s), seen[s] := true
        }
        if (nlist.Length >= 10)
            break
    }
    loop 10 {
        if (A_Index <= nlist.Length) {
            IniWrite(nlist[A_Index], INI_PATH, "servers", A_Index)
        } else {
            try {
                IniDelete(INI_PATH, "servers", A_Index)
            } catch {
            }
        }
    }
    try {
        if IsSet(ui) && ui.Has("serverDD") {
            _DD_InitAndChoose(ui["serverDD"], nlist, link)
            ui["link"].Value := link
        }
    } catch {
    }
}
RemoveServerPreset(link) {
    global INI_PATH, ui
    link := Trim(link)
    if (link = "")
        return
    list := LoadServerPresets()
    nlist := []
    for _, s in list
        if (Trim(s) != link)
            nlist.Push(s)
    if (nlist.Length = 0)
        nlist.Push(link)
    loop 10 {
        if (A_Index <= nlist.Length) {
            IniWrite(nlist[A_Index], INI_PATH, "servers", A_Index)
        } else {
            try {
                IniDelete(INI_PATH, "servers", A_Index)
            } catch {
            }
        }
    }
    try {
        if IsSet(ui) && ui.Has("serverDD") {
            _DD_InitAndChoose(ui["serverDD"], nlist, nlist[1])
            ui["link"].Value := ui["serverDD"].Text
        }
    } catch {
    }
}
_DD_InitAndChoose(dd, items, value) {
    list := []
    if IsObject(items) {
        for _, s in items
            list.Push(s)
    } else if (items != "") {
        list.Push(items)
    }
    dd.Delete()
    if (list.Length)
        dd.Add(list)

    foundIdx := 0
    for i, s in list
        if (s = value) {
            foundIdx := i
            break
        }
    if (!foundIdx) {
        dd.Add([value])
        foundIdx := list.Length + 1
        try {
            items.Push(value)
        } catch {
        }
    }
    dd.Choose(foundIdx)
}

LoadOverlaySettings() {
    global overlayEnabled, overlayX, overlayY, overlayW, overlayH, overlayOpacity
    global overlayFontSize, overlayTextColor, overlayBackColor, overlayShowSteps, overlayShowActive
    global overlayPadding, overlayRadius, overlayCompact, overlayTheme, INI_PATH
    if !FileExist(INI_PATH)
        return
    overlayEnabled   := Integer(IniRead(INI_PATH, "overlay", "enabled", overlayEnabled ? 1 : 0)) = 1
    overlayX         := Integer(IniRead(INI_PATH, "overlay", "x", overlayX))
    overlayY         := Integer(IniRead(INI_PATH, "overlay", "y", overlayY))
    overlayW         := Integer(IniRead(INI_PATH, "overlay", "w", overlayW))
    overlayH         := Integer(IniRead(INI_PATH, "overlay", "h", overlayH))
    overlayOpacity   := Integer(IniRead(INI_PATH, "overlay", "opacity", overlayOpacity))
    overlayFontSize  := Integer(IniRead(INI_PATH, "overlay", "fontSize", overlayFontSize))
    overlayTextColor := IniRead(INI_PATH, "overlay", "textColor", overlayTextColor)
    overlayBackColor := IniRead(INI_PATH, "overlay", "backColor", overlayBackColor)
    overlayShowSteps := Integer(IniRead(INI_PATH, "overlay", "showSteps", overlayShowSteps ? 1 : 0)) = 1
    overlayShowActive:= Integer(IniRead(INI_PATH, "overlay", "showActive", overlayShowActive ? 1 : 0)) = 1
    overlayPadding   := Integer(IniRead(INI_PATH, "overlay", "padding", overlayPadding))
    overlayRadius    := Integer(IniRead(INI_PATH, "overlay", "radius", overlayRadius))
    overlayCompact   := Integer(IniRead(INI_PATH, "overlay", "compact", overlayCompact ? 1 : 0)) = 1
    overlayTheme     := Integer(IniRead(INI_PATH, "overlay", "theme", overlayTheme))
}
SaveOverlaySettings() {
    global overlayEnabled, overlayX, overlayY, overlayW, overlayH, overlayOpacity
    global overlayFontSize, overlayTextColor, overlayBackColor, overlayShowSteps, overlayShowActive
    global overlayPadding, overlayRadius, overlayCompact, overlayTheme, INI_PATH
    IniWrite(overlayEnabled ? 1 : 0, INI_PATH, "overlay", "enabled")
    IniWrite(overlayX, INI_PATH, "overlay", "x")
    IniWrite(overlayY, INI_PATH, "overlay", "y")
    IniWrite(overlayW, INI_PATH, "overlay", "w")
    IniWrite(overlayH, INI_PATH, "overlay", "h")
    IniWrite(overlayOpacity, INI_PATH, "overlay", "opacity")
    IniWrite(overlayFontSize, INI_PATH, "overlay", "fontSize")
    IniWrite(overlayTextColor, INI_PATH, "overlay", "textColor")
    IniWrite(overlayBackColor, INI_PATH, "overlay", "backColor")
    IniWrite(overlayShowSteps ? 1 : 0, INI_PATH, "overlay", "showSteps")
    IniWrite(overlayShowActive ? 1 : 0, INI_PATH, "overlay", "showActive")
    IniWrite(overlayPadding, INI_PATH, "overlay", "padding")
    IniWrite(overlayRadius, INI_PATH, "overlay", "radius")
    IniWrite(overlayCompact ? 1 : 0, INI_PATH, "overlay", "compact")
    IniWrite(overlayTheme, INI_PATH, "overlay", "theme")
}
ApplyOverlayTheme(idx) {
    global overlayTextColor, overlayBackColor
    switch idx {
        case 0: overlayTextColor := "Lime",  overlayBackColor := "Black"
        case 1: overlayTextColor := "White", overlayBackColor := "Navy"
        case 2: overlayTextColor := "White", overlayBackColor := "0x2C2C2C"
    }
}
ApplyRoundedCorners(hwnd, w, h, radius) {
    try {
        if (radius <= 0) {
            DllCall("SetWindowRgn", "ptr", hwnd, "ptr", 0, "int", true)
            return
        }
        hrgn := DllCall("CreateRoundRectRgn", "int", 0, "int", 0, "int", w+1, "int", h+1, "int", radius, "int", radius, "ptr")
        DllCall("SetWindowRgn", "ptr", hwnd, "ptr", hrgn, "int", true)
    } catch {
    }
}
InitOverlay() {
    global _ov, overlayX, overlayY, overlayW, overlayH, overlayOpacity
    global overlayFontSize, overlayTextColor, overlayBackColor
    global overlayPadding, overlayRadius, overlayCompact, overlayTheme

    DestroyOverlay()
    ApplyOverlayTheme(overlayTheme)

    _ov := Gui("+AlwaysOnTop -Caption +ToolWindow +E0x20 +E0x08000000")
    _ov.BackColor := overlayBackColor
    _ov.SetFont("s" overlayFontSize " c" overlayTextColor " bold", "Segoe UI")

    P := overlayPadding
    lineH := Round(overlayFontSize * 1.8)

    if (overlayCompact) {
        _ov.Add("Text", "x" P " y" P " w" (overlayW - 2*P) " vHdr", "AR: --  |  ACTIVE: --")
    } else {
        _ov.Add("Text", "x" P " y" P " w" (overlayW - 2*P) " vHdr", "AR: --  |  ACTIVE: --  |  Next: --:--:--")
        _ov.Add("Text", "x" P " y" (P + lineH) " w" (overlayW - 2*P) " vSub", "Egg: STOP")
    }

    _ov.Show("x" overlayX " y" overlayY " w" overlayW " h" overlayH " NoActivate")
    try {
        WinSetTransparent(overlayOpacity, "ahk_id " _ov.Hwnd)
    } catch {
    }
    ApplyRoundedCorners(_ov.Hwnd, overlayW, overlayH, overlayRadius)
}
ResizeOverlay(newW, newH) {
    global _ov, overlayPadding, overlayRadius
    if !_ov
        return
    _ov.Show("w" newW " h" newH " NoActivate")
    P := overlayPadding
    try {
        if _ov.Has("Hdr")
            _ov["Hdr"].Opt("w" (newW - 2*P))
        if _ov.Has("Sub")
            _ov["Sub"].Opt("w" (newW - 2*P))
    } catch {
    }
    ApplyRoundedCorners(_ov.Hwnd, newW, newH, overlayRadius)
}
EstimateTextWidth(text, fontSize) {
    if (text = "")
        return 0
    return Round((StrLen(text) * fontSize * 0.62) * 1.08)
}
DestroyOverlay() {
    global _ov
    if (_ov) {
        try {
            _ov.Destroy()
        } catch {
        }
        _ov := 0
    }
}
UpdateOverlay() {
    global _ov, state, cfg, overlayShowSteps
    global overlayW, overlayH, overlayFontSize, overlayPadding, overlayCompact
    if !_ov
        return

    rem := state["nextRejoinTick"] - A_TickCount
    if (rem <= 0)
        rem := cfg["rejoinIntervalMin"] * 60000
    hrs  := Floor(rem / 3600000)
    mins := Floor(Mod(rem / 60000, 60))
    secs := Floor(Mod(rem / 1000, 60))

    ar := cfg["autoRejoinEnabled"] ? ("ON " Format("{:02}:{:02}:{:02}", hrs, mins, secs)) : "OFF"
    active := state["m1_running"] ? "Eggsterminator" : "None"

    if (overlayCompact) {
        _ov["Hdr"].Text := "AR: " ar "  |  ACTIVE: " active
    } else {
        _ov["Hdr"].Text := "AR: " ar "  |  ACTIVE: " active "  |  Next: " (cfg["autoRejoinEnabled"]
                          ? Format("{:02}:{:02}:{:02}", hrs, mins, secs) : "--:--:--")

        m1_running := state["m1_running"]

        if (overlayShowSteps && m1_running) {
            m1s := state["m1_step"]
            m1Elapsed := (state.Has("m1_stepStart") && state["m1_stepStart"] > 0)
                ? Round((A_TickCount - state["m1_stepStart"]) / 1000) : 0
            m1Text := "Egg[" m1s "]: " StepNameM1(m1s) " (" m1Elapsed "s)"
        } else {
            m1Text := "Egg: " (m1_running ? "RUN" : "STOP")
        }
        _ov["Sub"].Text := m1Text
    }

    textW1 := EstimateTextWidth(_ov["Hdr"].Text, overlayFontSize)
    textW2 := (!overlayCompact && _ov.Has("Sub")) ? EstimateTextWidth(_ov["Sub"].Text, overlayFontSize) : 0
    needW := Max(textW1, textW2) + (overlayPadding * 2)
    lineH := Round(overlayFontSize * 1.8)
    needH := (overlayCompact ? lineH : (lineH * 2)) + (overlayPadding * 2)

    if (needW > overlayW || needH > overlayH) {
        overlayW := Max(overlayW, needW)
        overlayH := Max(overlayH, needH)
        ResizeOverlay(overlayW, overlayH)
    } else {
        ResizeOverlay(overlayW, overlayH)
    }
}
ToggleOverlay() {
    global overlayEnabled
    overlayEnabled := !overlayEnabled
    if (overlayEnabled)
        InitOverlay()
    else
        DestroyOverlay()
    SaveOverlaySettings()
    ForceOverlayRefresh()
}
IncreaseOverlayOpacity() {
    global overlayOpacity, _ov
    overlayOpacity := Min(255, overlayOpacity + 10)
    if _ov {
        try {
            WinSetTransparent(overlayOpacity, "ahk_id " _ov.Hwnd)
        } catch {
        }
    }
    SaveOverlaySettings()
}
DecreaseOverlayOpacity() {
    global overlayOpacity, _ov
    overlayOpacity := Max(60, overlayOpacity - 10)
    if _ov {
        try {
            WinSetTransparent(overlayOpacity, "ahk_id " _ov.Hwnd)
        } catch {
        }
    }
    SaveOverlaySettings()
}
DragOverlay() {
    global _ov, overlayX, overlayY, overlayW, overlayH
    if !_ov
        return
    _ov.Opt("-E0x20")
    PostMessage(0xA1, 2,,, _ov.Hwnd)
    KeyWait("LButton")
    _ov.Opt("+E0x20")
    WinGetPos(&x, &y, &w, &h, "ahk_id " _ov.Hwnd)
    overlayX := x, overlayY := y, overlayW := w, overlayH := h
    SaveOverlaySettings()
}
SyncOverlayFromGui(apply := false) {
    SyncFromGui()
    if (apply) {
        if (overlayEnabled)
            InitOverlay()
        else
            DestroyOverlay()
    }
    SaveOverlaySettings()
    ForceOverlayRefresh()
}

LoadOverlaySettings()
if (overlayEnabled)
    InitOverlay()
SetTimer(UpdateOverlay, 400)

ui := BuildGui(cfg)

SetTimer(UpdateCountdown, 1000)
ApplyAutoRejoinTimer()

^!Up::IncreaseOverlayOpacity()
^!Down::DecreaseOverlayOpacity()
^!o::SyncOverlayFromGui(true)
Hotkey("Pause", (*) => StopAll(), "On")
Hotkey("~LButton", (*) => (
    (GetKeyState("Ctrl","P") && GetKeyState("Alt","P") && IsSet(_ov) && _ov) ? DragOverlay() : 0
))

AddField(win, x, y, labelTxt, editW, targetMap, key, initVal) {
    local lbl, lw, lh, ctrl, ew, eh
    lbl := win.Add("Text", "x" x " y" y, labelTxt)
    lbl.GetPos(, , &lw, &lh)
    x := x + lw + 6
    ctrl := win.Add("Edit", "x" x " y" (y - 2) " w" editW, initVal)
    targetMap[key] := ctrl
    ctrl.GetPos(, , &ew, &eh)
    return x + ew + 16
}

global _hkBound := Map()
NormalizeHotkey(hk) => Trim(hk)
UnregisterHotkey(name) {
    try {
        Hotkey(name,, "Off")
    } catch {
    }
}
BindHotkey(name, fnObj) {
    global _hkBound
    name := NormalizeHotkey(name)
    if (name = "")
        return
    if (!IsSet(_hkBound) || !IsObject(_hkBound))
        _hkBound := Map()
    if (_hkBound.Has(name))
        UnregisterHotkey(name)
    Hotkey(name, fnObj, "On")
    _hkBound[name] := fnObj
}
ApplyHotkeys() {
    global cfg, _hkBound, ui
    if (!IsSet(_hkBound) || !IsObject(_hkBound))
        _hkBound := Map()
    for name, _ in _hkBound
        UnregisterHotkey(name)
    _hkBound.Clear()

    if (Trim(cfg["hk_m1"]) != "")
        BindHotkey(cfg["hk_m1"], (*) => ToggleMacro1())
    if (Trim(cfg["hk_rejoin"]) != "")
        BindHotkey(cfg["hk_rejoin"], (*) => Rejoin())
    if (Trim(cfg["hk_overlay"]) != "")
        BindHotkey(cfg["hk_overlay"], (*) => ToggleOverlay())

    if (IsSet(ui) && ui.Has("btnM1"))
        ui["btnM1"].Text := "Start Eggsterminator (" cfg["hk_m1"] ")"
    if (IsSet(ui) && ui.Has("btnRejoin"))
        ui["btnRejoin"].Text := "Rejoin (" cfg["hk_rejoin"] ")"
}

BuildGui(cfg) {
    g := Map()
    win := Gui("+AlwaysOnTop +Resize +MinSize820x600", "Roblox Macro · Clean UI")
    win.MarginX := 10, win.MarginY := 8

    tabs := win.Add("Tab3", "w790 h500", ["General", "Eggsterminator", "Options", "Overlay"])

    tabs.UseTab("General")
    win.Add("GroupBox", "x10 y28 w770 h210", "Game & Server")
    x := 24, y := 50
    nx := AddField(win, x, y, "Private Server Link:", 580, g, "link", cfg["privateServerLink"])
    g["serverDD"] := win.Add("DropDownList", "x24 y" (y+26) " w628")
    _DD_InitAndChoose(g["serverDD"], LoadServerPresets(), cfg["privateServerLink"])
    g["serverDD"].OnEvent("Change", (*) => ( g["link"].Value := g["serverDD"].Text ))
    g["btnServerSave"] := win.Add("Button", "x+6 yp-1 w120", "Save")
    g["btnServerDel"]  := win.Add("Button", "x+6 yp-1 w120", "Remove")
    g["btnServerSave"].OnEvent("Click", (*) => SaveServerPreset(g["link"].Value))
    g["btnServerDel"].OnEvent("Click", (*) => RemoveServerPreset(g["serverDD"].Text))

    y := 120, x := 24
    nx := AddField(win, x, y, "Roblox EXE:", 240, g, "roblox", cfg["robloxExe"])
    nx := AddField(win, nx, y, "Browser EXE:", 240, g, "browser", cfg["browserExe"])
    g["browserDD"] := win.Add("DropDownList", "x" (nx-240) " y" (y+26) " w240")
    _DD_InitAndChoose(g["browserDD"], GetBrowserPresets(), cfg["browserExe"])
    g["browserDD"].OnEvent("Change", (*) => ( g["browser"].Value := g["browserDD"].Text ))

    y := 180
    nx := AddField(win, x, y, "Interval (min):", 60, g, "rejoinMin", cfg["rejoinIntervalMin"])
    nx := AddField(win, nx, y, "Detect Timeout (s):", 60, g, "detectTimeout", cfg["detectTimeoutSec"])

    y += 30, x := 24
    nx := AddField(win, x, y, "Pre-Relaunch (s):", 60, g, "preRelaunch", cfg["preRelaunchSec"])
    nx := AddField(win, nx, y, "Post Link Wait (s):", 60, g, "postLinkWait", cfg["postLinkWaitSec"])
    nx := AddField(win, nx, y, "Browser Grace (s):", 60, g, "browserGrace", cfg["browserGraceSec"])

    y += 32
    g["autoRejoinEnabled"] := win.Add("CheckBox", "x24 y" y, "Enable Auto Rejoin")
    g["autoRejoinEnabled"].Value := cfg["autoRejoinEnabled"]
    btnRG := win.Add("Button", "x+8 yp-4 w140", "Reset General")
    btnRG.OnEvent("Click", (*) => ResetTabDefaults("General"))

    tabs.UseTab("Eggsterminator")
    x := 24, y := 50
    nx := AddField(win, x, y, "Start Delay (s):", 60, g, "m1_startDelay",    cfg["m1_startDelaySec"])
    nx := AddField(win, nx, y, "Tick (ms):",       60, g, "m1_tick",          cfg["m1_tickMs"])
    nx := AddField(win, nx, y, "Move Time (s):",   60, g, "m1_moveDuration",  cfg["m1_moveDurationSec"])
    nx := AddField(win, nx, y, "Loop Wait (s):",   60, g, "m1_loopWait",      cfg["m1_loopWaitSec"])

    y += 30
    nx := AddField(win, x,  y, "Esc Pause (s):",   60, g, "m1_pause1",        cfg["m1_pause1Sec"])
    nx := AddField(win, nx, y, "'Reset' Pause (s):",60, g, "m1_pause2",       cfg["m1_pause2Sec"])

    y += 30
    nx := AddField(win, x,  y, "LeftX:",           70, g, "m1_LeftX",         cfg["m1_LeftX"])
    nx := AddField(win, nx, y, "RightX:",          70, g, "m1_RightX",        cfg["m1_RightX"])
    nx := AddField(win, nx, y, "CenterY:",         70, g, "m1_CenterY",       cfg["m1_CenterY"])
    nx := AddField(win, nx, y, "Amplitude:",       70, g, "m1_Amplitude",     cfg["m1_Amplitude"])
    nx := AddField(win, nx, y, "Speed:",           70, g, "m1_Speed",         cfg["m1_Speed"])

    y += 30, x := 24
    g["m1_showBox"] := win.Add("CheckBox", "x" x " y" y, "Show movement area box")
    g["m1_showBox"].Value := cfg["m1_showBox"]
    nx := AddField(win, x+220, y, "Box thickness:", 60, g, "m1_boxThickness", cfg["m1_boxThickness"])
    nx := AddField(win, nx, y, "Box color:", 100, g, "m1_boxColor", cfg["m1_boxColor"])

    y += 28, x := 24
    g["m1_showPath"] := win.Add("CheckBox", "x" x " y" y, "Show path dots")
    g["m1_showPath"].Value := cfg["m1_showPath"]
    nx := AddField(win, x+150, y, "Path color:", 100, g, "m1_pathColor", cfg["m1_pathColor"])
    nx := AddField(win, nx, y, "Step (px):", 60, g, "m1_pathStepPx", cfg["m1_pathStepPx"])
    nx := AddField(win, nx, y, "Dot size:", 60, g, "m1_pathDotSize", cfg["m1_pathDotSize"])

    y += 26, x := 24
    nx := AddField(win, x, y, "Cursor dot color:", 100, g, "m1_cursorDotColor", cfg["m1_cursorDotColor"])
    nx := AddField(win, nx, y, "Cursor dot size:", 80, g, "m1_cursorDotSize",  cfg["m1_cursorDotSize"])

    y += 26, x := 24
    win.Add("Text", "x" x " y" y " cGray", "Prep Keys")
    y += 18
    nx := AddField(win, x,  y, "Key1:",            80, g, "m1_key1",          cfg["m1_key1"])
    nx := AddField(win, nx, y, "Key1 hold (ms):",  80, g, "m1_key1HoldMs",    cfg["m1_key1HoldMs"])
    nx := AddField(win, nx, y, "Key2:",            80, g, "m1_key2",          cfg["m1_key2"])
    y += 26, x := 24
    nx := AddField(win, x,  y, "Key2 hold (ms):",  80, g, "m1_key2HoldMs",    cfg["m1_key2HoldMs"])
    nx := AddField(win, nx, y, "Post-Key2 delay (ms):", 100, g, "m1_postKey2DelayMs", cfg["m1_postKey2DelayMs"])
    nx := AddField(win, nx, y, "After-prep key:",  80, g, "m1_afterPrepKey",  cfg["m1_afterPrepKey"])

    y += 24, x := 24
    win.Add("Text", "x" x " y" y " cGray", "Confirm Keys")
    y += 18
    nx := AddField(win, x,  y, "Esc key:",         80, g, "m1_keyEsc",        cfg["m1_keyEsc"])
    nx := AddField(win, nx, y, "Reset key:",       80, g, "m1_keyReset",      cfg["m1_keyReset"])
    nx := AddField(win, nx, y, "Enter key:",       80, g, "m1_keyEnter",      cfg["m1_keyEnter"])

    y += 12
    btnRM1 := win.Add("Button", "x24 y" y " w180", "Reset Eggsterminator")
    btnRM1.OnEvent("Click", (*) => ResetTabDefaults("Eggsterminator"))

    tabs.UseTab("Options")
    g["showCountdownTip"] := win.Add("CheckBox","x24 y50","Show countdown tooltip")
    g["showCountdownTip"].Value := cfg["showCountdownTip"]

    y := 84
    win.Add("Text", "x24 y" y " Section", "Hotkeys")
    y += 22
    g["hk_m1"] := win.Add("Edit", "x24 y" y " w120", cfg["hk_m1"]),       win.Add("Text", "x+6 yp+3", "Egg (start/stop)")
    y += 28
    g["hk_rejoin"] := win.Add("Edit", "x24 y" y " w120", cfg["hk_rejoin"]), win.Add("Text", "x+6 yp+3", "Rejoin")
    y += 28
    g["hk_overlay"] := win.Add("Edit", "x24 y" y " w120", cfg["hk_overlay"]), win.Add("Text", "x+6 yp+3", "Toggle overlay")

    y += 32
    btnApplyHK := win.Add("Button", "x24 y" y " w160", "Apply Hotkeys Now")
    btnImport  := win.Add("Button", "x+12 yp w160", "Import Config…")
    btnApplyHK.OnEvent("Click", (*) => ( SyncFromGui(), SaveSettings(), ApplyHotkeys(), ToolTip("Hotkeys applied"), SetTimer(() => ToolTip(), -700) ))
    btnImport.OnEvent("Click", (*) => ImportConfig())
    y += 36
    btnRO := win.Add("Button", "x24 y" y " w160", "Reset Options")
    btnRO.OnEvent("Click", (*) => ResetTabDefaults("Options"))

    tabs.UseTab("Overlay")
    x := 24, y := 48
    g["ov_enabled"] := win.Add("CheckBox", "x" x " y" y, "Enable overlay")
    g["ov_enabled"].Value := overlayEnabled ? 1 : 0

    y += 26
    nx := AddField(win, x, y, "Font size:", 60, g, "ov_fontSize", overlayFontSize)
    nx := AddField(win, nx, y, "Width:", 60, g, "ov_width", overlayW)
    nx := AddField(win, nx, y, "Height:", 60, g, "ov_height", overlayH)

    y += 26
    nx := AddField(win, x, y, "Padding (px):", 60, g, "ov_padding", overlayPadding)
    nx := AddField(win, nx, y, "Corner radius:", 60, g, "ov_radius", overlayRadius)

    y += 26
    nx := AddField(win, x, y, "Text color:", 220, g, "ov_textColor", overlayTextColor)
    nx := AddField(win, nx, y, "Background:", 220, g, "ov_backColor", overlayBackColor)

    y += 26
    win.Add("Text", "x" x " y" y, "Theme:")
    g["ov_theme"] := win.Add("DropDownList", "x+6 yp-2 w180", ["Neo Lime", "Ocean", "Slate"])
    g["ov_theme"].Choose(overlayTheme + 1)

    y += 28
    g["ov_compact"] := win.Add("CheckBox", "x" x " y" y, "Compact (one line)")
    g["ov_compact"].Value := overlayCompact ? 1 : 0

    y += 22
    g["ov_showSteps"] := win.Add("CheckBox", "x" x " y" y, "Show step names + elapsed")
    g["ov_showSteps"].Value := overlayShowSteps

    y += 22
    g["ov_showActive"] := win.Add("CheckBox", "x" x " y" y, "Show ACTIVE macro")
    g["ov_showActive"].Value := overlayShowActive

    y += 30
    g["btnOvApply"] := win.Add("Button", "x" x " y" y " w160", "Apply Overlay")
    btnROv := win.Add("Button", "x+12 yp w160", "Reset Overlay")
    g["btnOvApply"].OnEvent("Click", (*) => SyncOverlayFromGui(true))
    btnROv.OnEvent("Click", (*) => ResetTabDefaults("Overlay"))

    tabs.UseTab()

    win.Add("Text","xm","Status:")
    g["status"] := win.Add("Text","x+6 w360","Eggsterminator: Stopped")
    g["countdown"] := win.Add("Text","x+10 w260","Next Rejoin: --h --m --s")

    g["btnM1"] := win.Add("Button","xm w220","Start Eggsterminator (" cfg["hk_m1"] ")")
    g["btnRejoin"] := win.Add("Button","x+8 w130","Rejoin (" cfg["hk_rejoin"] ")")
    g["btnSave"] := win.Add("Button","x+8 w90","Save")
    g["btnExit"] := win.Add("Button","x+8 w90","Exit")

    g["btnM1"].OnEvent("Click", (*) => ToggleMacro1())
    g["btnRejoin"].OnEvent("Click", (*) => Rejoin())
    g["btnSave"].OnEvent("Click", (*) => (
        SyncFromGui(),
        SaveSettings(),
        ApplyAutoRejoinTimer(),
        ApplyHotkeys(),
        SyncOverlayFromGui(false),
        ToolTip("Saved"), SetTimer(() => ToolTip(), -700)
    ))
    g["btnExit"].OnEvent("Click", (*) => ExitApp())

    win.Show("w840 h600")
    g["win"] := win

    ApplyHotkeys()
    return g
}

RefreshGuiFromCfg(g, cfg) {
    g["link"].Value := cfg["privateServerLink"]
    g["roblox"].Value := cfg["robloxExe"]
    g["browser"].Value := cfg["browserExe"]

    if g.Has("serverDD") {
        serverList := LoadServerPresets()
        _DD_InitAndChoose(g["serverDD"], serverList, cfg["privateServerLink"])
    }
    if g.Has("browserDD") {
        browserList := GetBrowserPresets()
        _DD_InitAndChoose(g["browserDD"], browserList, cfg["browserExe"])
    }

    g["rejoinMin"].Value := cfg["rejoinIntervalMin"]
    g["preRelaunch"].Value := cfg["preRelaunchSec"]
    g["postLinkWait"].Value := cfg["postLinkWaitSec"]
    g["detectTimeout"].Value := cfg["detectTimeoutSec"]
    g["browserGrace"].Value := cfg["browserGraceSec"]

    g["m1_startDelay"].Value := cfg["m1_startDelaySec"]
    g["m1_tick"].Value := cfg["m1_tickMs"]
    g["m1_moveDuration"].Value := cfg["m1_moveDurationSec"]
    g["m1_loopWait"].Value := cfg["m1_loopWaitSec"]
    g["m1_pause1"].Value := cfg["m1_pause1Sec"]
    g["m1_pause2"].Value := cfg["m1_pause2Sec"]
    g["m1_LeftX"].Value := cfg["m1_LeftX"]
    g["m1_RightX"].Value := cfg["m1_RightX"]
    g["m1_CenterY"].Value := cfg["m1_CenterY"]
    g["m1_Amplitude"].Value := cfg["m1_Amplitude"]
    g["m1_Speed"].Value := cfg["m1_Speed"]

    if g.Has("m1_showBox")
        g["m1_showBox"].Value := cfg["m1_showBox"]
    if g.Has("m1_boxThickness")
        g["m1_boxThickness"].Value := cfg["m1_boxThickness"]
    if g.Has("m1_boxColor")
        g["m1_boxColor"].Value := cfg["m1_boxColor"]

    if g.Has("m1_showPath")
        g["m1_showPath"].Value := cfg["m1_showPath"]
    if g.Has("m1_pathColor")
        g["m1_pathColor"].Value := cfg["m1_pathColor"]
    if g.Has("m1_pathStepPx")
        g["m1_pathStepPx"].Value := cfg["m1_pathStepPx"]
    if g.Has("m1_pathDotSize")
        g["m1_pathDotSize"].Value := cfg["m1_pathDotSize"]
    if g.Has("m1_cursorDotColor")
        g["m1_cursorDotColor"].Value := cfg["m1_cursorDotColor"]
    if g.Has("m1_cursorDotSize")
        g["m1_cursorDotSize"].Value := cfg["m1_cursorDotSize"]

    g["m1_key1"].Value := cfg["m1_key1"]
    g["m1_key1HoldMs"].Value := cfg["m1_key1HoldMs"]
    g["m1_key2"].Value := cfg["m1_key2"]
    g["m1_key2HoldMs"].Value := cfg["m1_key2HoldMs"]
    g["m1_postKey2DelayMs"].Value := cfg["m1_postKey2DelayMs"]
    g["m1_afterPrepKey"].Value := cfg["m1_afterPrepKey"]
    g["m1_keyEsc"].Value := cfg["m1_keyEsc"]
    g["m1_keyReset"].Value := cfg["m1_keyReset"]
    g["m1_keyEnter"].Value := cfg["m1_keyEnter"]

    if g.Has("hk_m1") {
        g["hk_m1"].Value := cfg["hk_m1"]
        g["hk_rejoin"].Value := cfg["hk_rejoin"]
        g["hk_overlay"].Value := cfg["hk_overlay"]
    }

    g["showCountdownTip"].Value := cfg["showCountdownTip"]
    if g.Has("autoRejoinEnabled")
        g["autoRejoinEnabled"].Value := cfg["autoRejoinEnabled"]

    if g.Has("ov_width")
        g["ov_width"].Value := overlayW
    if g.Has("ov_height")
        g["ov_height"].Value := overlayH
    if g.Has("ov_padding")
        g["ov_padding"].Value := overlayPadding
    if g.Has("ov_radius")
        g["ov_radius"].Value := overlayRadius
    if g.Has("ov_theme")
        g["ov_theme"].Choose(overlayTheme + 1)
    if g.Has("ov_compact")
        g["ov_compact"].Value := overlayCompact ? 1 : 0

    if (g.Has("btnM1"))
        g["btnM1"].Text := "Start Eggsterminator (" cfg["hk_m1"] ")"
    if (g.Has("btnRejoin"))
        g["btnRejoin"].Text := "Rejoin (" cfg["hk_rejoin"] ")"
}

LoadSettings() {
    global DEFAULT, INI_PATH, state
    out := Map()
    for key, def in DEFAULT {
        section := (key ~= "^m1_") ? "macro" : "main"
        val := FileExist(INI_PATH) ? IniRead(INI_PATH, section, key, def) : def
        if (IsNumber(def))
            val := ParseInt(val, def)
        out[key] := val
    }
    state["m1_mouseX"] := out["m1_LeftX"]
    state["nextRejoinTick"] := A_TickCount + (out["rejoinIntervalMin"] * 60000)
    return out
}
SaveSettings() {
    global cfg
    for key, val in cfg {
        section := (key ~= "^m1_") ? "macro" : "main"
        IniWrite(val, INI_PATH, section, key)
    }
}
ParseInt(val, def := 0) {
    val := RegExReplace(val, "[^\d-]")
    if (val = "" || val = "-")
        return def
    try {
        return Integer(val)
    } catch {
        return def
    }
}

_OvReadIntFrom(file, name, fallback, minV := "", maxV := "") {
    val := fallback
    try {
        val := IniRead(file, "overlay", name, fallback)
    } catch {
        val := fallback
    }
    v := fallback
    try {
        v := Integer(val)
    } catch {
        v := fallback
    }
    if (minV != "" && IsNumber(minV) && v < minV)
        v := minV
    if (maxV != "" && IsNumber(maxV) && v > maxV)
        v := maxV
    return v
}
_OvReadStrFrom(file, name, fallback) {
    s := fallback
    try {
        s := IniRead(file, "overlay", name, fallback)
    } catch {
        s := fallback
    }
    return s
}
_OvReadBoolFrom(file, name, fallback) {
    raw := fallback ? 1 : 0
    try {
        raw := IniRead(file, "overlay", name, fallback ? 1 : 0)
    } catch {
        raw := fallback ? 1 : 0
    }
    v := fallback ? 1 : 0
    try {
        v := Integer(raw)
    } catch {
        v := (fallback ? 1 : 0)
    }
    return v ? 1 : 0
}

ImportConfig() {
    global DEFAULT, cfg, ui
    global overlayEnabled, overlayX, overlayY, overlayW, overlayH, overlayOpacity
    global overlayFontSize, overlayTextColor, overlayBackColor, overlayShowSteps, overlayShowActive
    global overlayPadding, overlayRadius, overlayCompact, overlayTheme

    path := FileSelect("S16",, "Select settings INI to import", "INI (*.ini)")
    if (!path)
        return

    for key, def in DEFAULT {
        section := (key ~= "^m1_") ? "macro" : "main"
        val := ""
        try {
            val := IniRead(path, section, key, "")
        } catch {
            val := ""
        }
        if (val != "") {
            if (IsNumber(def))
                val := ParseInt(val, def)
            cfg[key] := val
        }
    }

    overlayEnabled    := _OvReadBoolFrom(path, "enabled",   overlayEnabled)
    overlayX          := _OvReadIntFrom(path, "x",          overlayX)
    overlayY          := _OvReadIntFrom(path, "y",          overlayY)
    overlayW          := _OvReadIntFrom(path, "w",          overlayW, 120)
    overlayH          := _OvReadIntFrom(path, "h",          overlayH, 36)
    overlayOpacity    := _OvReadIntFrom(path, "opacity",    overlayOpacity, 60, 255)
    overlayFontSize   := _OvReadIntFrom(path, "fontSize",   overlayFontSize, 8)
    overlayTextColor  := _OvReadStrFrom(path, "textColor",  overlayTextColor)
    overlayBackColor  := _OvReadStrFrom(path, "backColor",  overlayBackColor)
    overlayShowSteps  := _OvReadBoolFrom(path, "showSteps", overlayShowSteps)
    overlayShowActive := _OvReadBoolFrom(path, "showActive",overlayShowActive)
    overlayPadding    := _OvReadIntFrom(path, "padding",    overlayPadding, 0)
    overlayRadius     := _OvReadIntFrom(path, "radius",     overlayRadius, 0)
    overlayCompact    := _OvReadBoolFrom(path, "compact",   overlayCompact)

    tmp := ""
    try {
        tmp := IniRead(path, "overlay", "theme", "")
    } catch {
        tmp := ""
    }
    if (tmp != "") {
        try {
            overlayTheme := Integer(tmp)
            ApplyOverlayTheme(overlayTheme)
        } catch {
        }
    }

    SaveSettings()
    SaveOverlaySettings()
    RefreshGuiFromCfg(ui, cfg)
    ApplyHotkeys()
    ApplyAutoRejoinTimer()

    if (overlayEnabled)
        InitOverlay()
    else
        DestroyOverlay()
    ForceOverlayRefresh()
}

SyncFromGui() {
    global ui, cfg, DEFAULT
    global overlayW, overlayH, overlayPadding, overlayRadius, overlayCompact, overlayTheme
    global overlayEnabled, overlayFontSize, overlayTextColor, overlayBackColor, overlayOpacity
    global overlayShowSteps, overlayShowActive

    cfg["privateServerLink"] := ui["link"].Value
    cfg["robloxExe"]         := ui["roblox"].Value
    cfg["browserExe"]        := ui["browser"].Value

    cfg["rejoinIntervalMin"] := Max(1, ParseInt(ui["rejoinMin"].Value, DEFAULT["rejoinIntervalMin"]))
    cfg["preRelaunchSec"]    := Max(0, ParseInt(ui["preRelaunch"].Value, DEFAULT["preRelaunchSec"]))
    cfg["postLinkWaitSec"]   := Max(0, ParseInt(ui["postLinkWait"].Value, DEFAULT["postLinkWaitSec"]))
    cfg["detectTimeoutSec"]  := Max(1, ParseInt(ui["detectTimeout"].Value, DEFAULT["detectTimeoutSec"]))
    cfg["browserGraceSec"]   := Max(0, ParseInt(ui["browserGrace"].Value, DEFAULT["browserGraceSec"]))

    if (ui.Has("autoRejoinEnabled"))
        cfg["autoRejoinEnabled"] := ui["autoRejoinEnabled"].Value ? 1 : 0

    cfg["m1_startDelaySec"]   := Max(0, ParseInt(ui["m1_startDelay"].Value, DEFAULT["m1_startDelaySec"]))
    cfg["m1_tickMs"]          := Max(5, ParseInt(ui["m1_tick"].Value, DEFAULT["m1_tickMs"]))
    cfg["m1_moveDurationSec"] := Max(1, ParseInt(ui["m1_moveDuration"].Value, DEFAULT["m1_moveDurationSec"]))
    cfg["m1_loopWaitSec"]     := Max(0, ParseInt(ui["m1_loopWait"].Value, DEFAULT["m1_loopWaitSec"]))
    cfg["m1_pause1Sec"]       := Max(0, ParseInt(ui["m1_pause1"].Value, DEFAULT["m1_pause1Sec"]))
    cfg["m1_pause2Sec"]       := Max(0, ParseInt(ui["m1_pause2"].Value, DEFAULT["m1_pause2Sec"]))
    cfg["m1_LeftX"]           := ParseInt(ui["m1_LeftX"].Value, DEFAULT["m1_LeftX"])
    cfg["m1_RightX"]          := ParseInt(ui["m1_RightX"].Value, DEFAULT["m1_RightX"])
    cfg["m1_CenterY"]         := ParseInt(ui["m1_CenterY"].Value, DEFAULT["m1_CenterY"])
    cfg["m1_Amplitude"]       := Max(1, ParseInt(ui["m1_Amplitude"].Value, DEFAULT["m1_Amplitude"]))
    cfg["m1_Speed"]           := Max(1, ParseInt(ui["m1_Speed"].Value, DEFAULT["m1_Speed"]))
    if (cfg["m1_RightX"] < cfg["m1_LeftX"]) {
        tmp := cfg["m1_LeftX"], cfg["m1_LeftX"] := cfg["m1_RightX"], cfg["m1_RightX"] := tmp
        ui["m1_LeftX"].Value := cfg["m1_LeftX"], ui["m1_RightX"].Value := cfg["m1_RightX"]
    }

    if (ui.Has("m1_showBox"))
        cfg["m1_showBox"] := ui["m1_showBox"].Value ? 1 : 0
    if (ui.Has("m1_boxThickness"))
        cfg["m1_boxThickness"] := Max(1, ParseInt(ui["m1_boxThickness"].Value, DEFAULT["m1_boxThickness"]))
    if (ui.Has("m1_boxColor"))
        cfg["m1_boxColor"] := Trim(ui["m1_boxColor"].Value)

    if (ui.Has("m1_showPath")) {
        cfg["m1_showPath"]       := ui["m1_showPath"].Value ? 1 : 0
        cfg["m1_pathColor"]      := Trim(ui["m1_pathColor"].Value)
        cfg["m1_pathStepPx"]     := Max(4, ParseInt(ui["m1_pathStepPx"].Value, DEFAULT["m1_pathStepPx"]))
        cfg["m1_pathDotSize"]    := Max(1, ParseInt(ui["m1_pathDotSize"].Value, DEFAULT["m1_pathDotSize"]))
        cfg["m1_cursorDotColor"] := Trim(ui["m1_cursorDotColor"].Value)
        cfg["m1_cursorDotSize"]  := Max(2, ParseInt(ui["m1_cursorDotSize"].Value, DEFAULT["m1_cursorDotSize"]))
    }

    cfg["m1_key1"]            := Trim(ui["m1_key1"].Value)
    cfg["m1_key1HoldMs"]      := Max(0, ParseInt(ui["m1_key1HoldMs"].Value, DEFAULT["m1_key1HoldMs"]))
    cfg["m1_key2"]            := Trim(ui["m1_key2"].Value)
    cfg["m1_key2HoldMs"]      := Max(0, ParseInt(ui["m1_key2HoldMs"].Value, DEFAULT["m1_key2HoldMs"]))
    cfg["m1_postKey2DelayMs"] := Max(0, ParseInt(ui["m1_postKey2DelayMs"].Value, DEFAULT["m1_postKey2DelayMs"]))
    cfg["m1_afterPrepKey"]    := ui["m1_afterPrepKey"].Value
    cfg["m1_keyEsc"]          := Trim(ui["m1_keyEsc"].Value)
    cfg["m1_keyReset"]        := Trim(ui["m1_keyReset"].Value)
    cfg["m1_keyEnter"]        := Trim(ui["m1_keyEnter"].Value)

    if (ui.Has("hk_m1")) {
        cfg["hk_m1"]      := Trim(ui["hk_m1"].Value)
        cfg["hk_rejoin"]  := Trim(ui["hk_rejoin"].Value)
        cfg["hk_overlay"] := Trim(ui["hk_overlay"].Value)
    }

    cfg["showCountdownTip"]   := ui["showCountdownTip"].Value ? 1 : 0

    overlayEnabled   := ui["ov_enabled"].Value ? true : false
    overlayFontSize  := Max(8, ParseInt(ui["ov_fontSize"].Value, overlayFontSize))
    overlayW         := Max(120, ParseInt(ui.Has("ov_width")   ? ui["ov_width"].Value   : overlayW, overlayW))
    overlayH         := Max(36,  ParseInt(ui.Has("ov_height")  ? ui["ov_height"].Value  : overlayH, overlayH))
    overlayPadding   := Max(0,   ParseInt(ui.Has("ov_padding") ? ui["ov_padding"].Value : overlayPadding, overlayPadding))
    overlayRadius    := Max(0,   ParseInt(ui.Has("ov_radius")  ? ui["ov_radius"].Value  : overlayRadius, overlayRadius))
    if (ui.Has("ov_theme")) {
        overlayTheme := ui["ov_theme"].Value - 1
        ApplyOverlayTheme(overlayTheme)
    }
    overlayTextColor := ui.Has("ov_textColor") ? ui["ov_textColor"].Value : overlayTextColor
    overlayBackColor := ui.Has("ov_backColor") ? ui["ov_backColor"].Value : overlayBackColor
    ovOpacityInput   := ui.Has("ov_opacity") ? ui["ov_opacity"].Value : overlayOpacity
    overlayOpacity   := Max(60, Min(255, ParseInt(ovOpacityInput, overlayOpacity)))
    overlayCompact   := ui.Has("ov_compact")   ? (ui["ov_compact"].Value ? true : false) : overlayCompact
    overlayShowSteps := ui.Has("ov_showSteps") ? (ui["ov_showSteps"].Value ? true : false) : overlayShowSteps
    overlayShowActive:= ui.Has("ov_showActive")? (ui["ov_showActive"].Value ? true : false) : overlayShowActive

    if (state["m1_running"])
        M1Box_Update()
}

UpdateStatusUI() {
    global ui, state
    if !IsSet(ui) || !ui.Has("status")
        return
    m1 := state["m1_running"] ? "Eggsterminator: Running" : "Eggsterminator: Stopped"
    ui["status"].Text := m1
}
ForceOverlayRefresh() => UpdateOverlay()

UpdateCountdown() {
    global ui, cfg, state
    if (!cfg["autoRejoinEnabled"]) {
        if (IsSet(ui) && ui.Has("countdown"))
            ui["countdown"].Text := "Next Rejoin: OFF"
        ToolTip()
        UpdateStatusUI()
        return
    }
    rem := state["nextRejoinTick"] - A_TickCount
    if (rem <= 0) {
        state["nextRejoinTick"] := A_TickCount + (cfg["rejoinIntervalMin"] * 60000)
        rem := cfg["rejoinIntervalMin"] * 60000
    }
    hrs := Floor(rem / 3600000)
    mins := Floor(Mod(rem / 60000, 60))
    secs := Floor(Mod(rem / 1000, 60))
    if (IsSet(ui) && ui.Has("countdown"))
        ui["countdown"].Text := "Next Rejoin: " hrs "h " mins "m " secs "s"
    if (cfg["showCountdownTip"])
        ToolTip("Next Auto Rejoin in " hrs "h " mins "m " secs "s", 10, 10)
    else
        ToolTip()
    UpdateStatusUI()
}
ApplyAutoRejoinTimer() {
    global cfg, state
    SetTimer(Rejoin, 0)
    if (cfg["autoRejoinEnabled"]) {
        SetTimer(Rejoin, cfg["rejoinIntervalMin"] * 60000)
        state["nextRejoinTick"] := A_TickCount + (cfg["rejoinIntervalMin"] * 60000)
    } else {
        state["nextRejoinTick"] := A_TickCount + (cfg["rejoinIntervalMin"] * 60000)
    }
    ForceOverlayRefresh()
}

StartMacro1() {
    SyncFromGui()
    global state, cfg, _rbxHwnd, _lastFocusTick
    if (state["m1_running"])
        return
    state["m1_running"] := true
    state["m1_step"] := -1
    state["m1_stepStart"] := A_TickCount
    state["m1_sub"] := 0
    state["m1_mouseX"] := cfg["m1_LeftX"]
    state["m1_lastDownRefresh"] := 0
    _rbxHwnd := FindRobloxHwnd()
    _lastFocusTick := 0
    EnsureRobloxFocus(0, false)
    SetTimer(RunMacro1Step, 0)
    SetTimer(RunMacro1Step, cfg["m1_tickMs"])
    M1Box_Show()
    M1Path_Init()
    MouseGetPos(&mx, &my)
    state["m1_lastX"] := mx
    state["m1_lastY"] := my
    ForceOverlayRefresh()
}
ToggleMacro1() {
    SyncFromGui()
    global state
    if (state["m1_running"])
        StopMacro1()
    else
        StartMacro1()
}
StopMacro1() {
    global state
    state["m1_running"] := false
    SetTimer(RunMacro1Step, 0)
    if (state["m1_isDown"]) {
        LMB_Up()
        state["m1_isDown"] := false
    }
    state["m1_step"] := 0
    state["m1_stepStart"] := 0
    state["m1_sub"] := 0
    state["m1_lastX"] := 0
    state["m1_lastY"] := 0
    state["m1_lastDownRefresh"] := 0
    M1Box_Hide()
    ForceOverlayRefresh()
}
MakeKeyDown(keyName) => "{" keyName " down}"
MakeKeyUp(keyName)   => "{" keyName " up}"

RunMacro1Step() {
    global state, cfg
    if !state["m1_running"]
        return

    if (state["m1_step"] = 0 || state["m1_step"] = 1 || state["m1_step"] = 2)
        EnsureRobloxFocus(300, true)

    if (state["m1_step"] = -1) {
        if (A_TickCount - state["m1_stepStart"] >= cfg["m1_startDelaySec"] * 1000) {
            state["m1_step"] := 0
            state["m1_sub"]  := 0
            M1Box_Update()
        }
        return
    }

    if (state["m1_step"] = 0) {
        switch state["m1_sub"] {
            case 0:
                Send(MakeKeyDown(cfg["m1_key1"]))
                Send(MakeKeyDown(cfg["m1_key2"]))
                state["m1_stepStart"] := A_TickCount
                state["m1_sub"] := 1
            case 1:
                if (A_TickCount - state["m1_stepStart"] >= Max(0, cfg["m1_key2HoldMs"])) {
                    Send(MakeKeyUp(cfg["m1_key2"]))
                    state["m1_stepStart"] := A_TickCount
                    state["m1_sub"] := 2
                }
            case 2:
                if (A_TickCount - state["m1_stepStart"] >= Max(0, cfg["m1_postKey2DelayMs"])) {
                    state["m1_topUp"] := Max(0, cfg["m1_key1HoldMs"] - (cfg["m1_key2HoldMs"] + cfg["m1_postKey2DelayMs"]))
                    state["m1_stepStart"] := A_TickCount
                    state["m1_sub"] := 3
                }
            case 3:
                if (A_TickCount - state["m1_stepStart"] >= state["m1_topUp"]) {
                    Send(MakeKeyUp(cfg["m1_key1"]))
                    if (cfg["m1_afterPrepKey"] != "")
                        Send(cfg["m1_afterPrepKey"])
                    state["m1_stepStart"] := A_TickCount
                    state["m1_sub"] := 0
                    state["m1_step"] := 1
                }
        }
        return
    }

    if (state["m1_step"] = 1) {
        if (!state["m1_isDown"]) {
            LMB_Down()
            state["m1_isDown"] := true
            state["m1_lastDownRefresh"] := A_TickCount
        } else {
            EnsureLMBHeld(400)
        }

        elapsed := A_TickCount - state["m1_stepStart"]
        state["m1_mouseX"] += cfg["m1_Speed"]
        if (state["m1_mouseX"] > cfg["m1_RightX"])
            state["m1_mouseX"] := cfg["m1_LeftX"]
        mousePosY := cfg["m1_CenterY"] + Sin(state["m1_mouseX"] / 50) * cfg["m1_Amplitude"]

        nextX := state["m1_mouseX"]
        nextY := mousePosY
        MoveMouseAbsolute(nextX, nextY, 0)
        dx := nextX - state["m1_lastX"]
        dy := nextY - state["m1_lastY"]
        if (dx || dy)
            MoveMouseRelative(dx, dy)
        state["m1_lastX"] := nextX
        state["m1_lastY"] := nextY

        M1Path_MoveCursor(nextX, nextY)

        if (elapsed >= cfg["m1_moveDurationSec"] * 1000) {
            if (state["m1_isDown"]) {
                LMB_Up()
                state["m1_isDown"] := false
            }
            state["m1_stepStart"] := A_TickCount
            state["m1_sub"] := 0
            state["m1_step"] := 2
        }
        return
    }

    if (state["m1_step"] = 2) {
        switch state["m1_sub"] {
            case 0:
                Send(MakeKeyDown(cfg["m1_keyEsc"])), Send(MakeKeyUp(cfg["m1_keyEsc"]))
                state["m1_stepStart"] := A_TickCount
                state["m1_sub"] := 1
            case 1:
                if (A_TickCount - state["m1_stepStart"] >= cfg["m1_pause1Sec"] * 1000) {
                    if (cfg["m1_keyReset"] != "")
                        Send(cfg["m1_keyReset"])
                    state["m1_stepStart"] := A_TickCount
                    state["m1_sub"] := 2
                }
            case 2:
                if (A_TickCount - state["m1_stepStart"] >= cfg["m1_pause2Sec"] * 1000) {
                    Send(MakeKeyDown(cfg["m1_keyEnter"])), Send(MakeKeyUp(cfg["m1_keyEnter"]))
                    state["m1_stepStart"] := A_TickCount
                    state["m1_sub"] := 0
                    state["m1_step"] := 3
                }
        }
        return
    }

    if (state["m1_step"] = 3) {
        if (A_TickCount - state["m1_stepStart"] >= cfg["m1_loopWaitSec"] * 1000) {
            state["m1_step"] := 0
            state["m1_mouseX"] := cfg["m1_LeftX"]
            state["m1_sub"] := 0
        }
    }
}

Rejoin() {
    global state, cfg

    wasM1 := state["m1_running"]
    StopMacro1()

    ToolTip("Auto Rejoin: Closing Roblox...")
    For proc in ["RobloxPlayerBeta.exe", "RobloxCrashHandler.exe", "Roblox.exe"] {
        RunWait("taskkill /F /IM " proc " /T",, "Hide")
        Sleep(200)
    }

    start := A_TickCount
    Loop {
        if !ProcessExistName("RobloxPlayerBeta.exe") && !ProcessExistName("Roblox.exe")
            break
        if (A_TickCount - start) > cfg["detectTimeoutSec"]*1000
            break
        Sleep(500)
    }

    ToolTip("Auto Rejoin: Waiting " cfg["preRelaunchSec"] "s...")
    Sleep(cfg["preRelaunchSec"] * 1000)

    hadBrowser := ProcessExistName(cfg["browserExe"]) ? true : false

    ToolTip("Auto Rejoin: Opening server link...")
    Run(cfg["privateServerLink"])
    Sleep(cfg["postLinkWaitSec"] * 1000)

    detectStart := A_TickCount
    Loop {
        if ProcessExistName(cfg["robloxExe"]) {
            Sleep(cfg["browserGraceSec"] * 1000)
            break
        }
        if (A_TickCount - detectStart) > cfg["detectTimeoutSec"]*1000
            break
        Sleep(300)
    }

    try {
        if (!hadBrowser && ProcessExistName(cfg["browserExe"]))
            ProcessClose(cfg["browserExe"])
    } catch {
    }

    ToolTip()
    state["nextRejoinTick"] := A_TickCount + (cfg["rejoinIntervalMin"] * 60000)

    if (wasM1)
        StartMacro1()
    ForceOverlayRefresh()
}

M1Box_Show() {
    global cfg
    if (!cfg["m1_showBox"]) {
        M1Box_Hide()
        return
    }
    M1Box_Update()
}
M1Box_Hide() {
    global _m1bxT, _m1bxB, _m1bxL, _m1bxR
    for _, ref in [_m1bxT, _m1bxB, _m1bxL, _m1bxR] {
        if ref {
            try {
                ref.Destroy()
            } catch {
            }
        }
    }
    _m1bxT := 0, _m1bxB := 0, _m1bxL := 0, _m1bxR := 0
    M1Path_Clear()
}
M1Box_ShowSide(slot, x, y, w, h, color) {
    try {
        if slot {
            slot.Show("x" x " y" y " w" w " h" h " NoActivate")
        } else {
            slot := Gui("+AlwaysOnTop -Caption +ToolWindow +E0x20 +E0x08000000")
            slot.BackColor := color
            slot.Show("x" x " y" y " w" w " h" h " NoActivate")
        }
    } catch {
    }
    return slot
}
M1Box_Update() {
    global cfg, _m1bxT, _m1bxB, _m1bxL, _m1bxR
    if (!cfg["m1_showBox"]) {
        M1Box_Hide()
        return
    }
    left := cfg["m1_LeftX"]
    width := Max(1, cfg["m1_RightX"] - cfg["m1_LeftX"])
    top := cfg["m1_CenterY"] - cfg["m1_Amplitude"]
    height := Max(1, cfg["m1_Amplitude"] * 2)

    left := Max(0, Min(left, A_ScreenWidth-1))
    top  := Max(0, Min(top,  A_ScreenHeight-1))
    width  := Max(1, Min(width,  A_ScreenWidth - left))
    height := Max(1, Min(height, A_ScreenHeight - top))

    th := Max(1, cfg["m1_boxThickness"])
    color := cfg["m1_boxColor"]

    _m1bxT := M1Box_ShowSide(_m1bxT, left, top, width, th, color)
    _m1bxB := M1Box_ShowSide(_m1bxB, left, top + height - th, width, th, color)
    _m1bxL := M1Box_ShowSide(_m1bxL, left, top, th, height, color)
    _m1bxR := M1Box_ShowSide(_m1bxR, left + width - th, top, th, height, color)

    if (cfg["m1_showPath"]) {
        M1Path_Rebuild(left, width, cfg["m1_CenterY"], cfg["m1_Amplitude"])
    } else {
        M1Path_Clear()
        M1Path_Init()
    }
}

M1Path_Init() {
    global _m1CurDot, cfg
    if _m1CurDot
        return
    size := Max(2, cfg["m1_cursorDotSize"])
    _m1CurDot := Gui("+AlwaysOnTop -Caption +ToolWindow +E0x20 +E0x08000000")
    _m1CurDot.BackColor := cfg["m1_cursorDotColor"]
    _m1CurDot.Show("x-1000 y-1000 w" size " h" size " NoActivate")
}
M1Path_Clear() {
    global _m1Dots, _m1CurDot
    for _, g in _m1Dots {
        try {
            g.Destroy()
        } catch {
        }
    }
    _m1Dots := []
    if _m1CurDot {
        try {
            _m1CurDot.Destroy()
        } catch {
        }
        _m1CurDot := 0
    }
}
M1Path_Rebuild(left, width, centerY, amplitude) {
    global cfg, _m1Dots
    M1Path_Clear()
    step := Max(4, cfg["m1_pathStepPx"])
    dotSize := Max(1, cfg["m1_pathDotSize"])
    color := cfg["m1_pathColor"]

    xStart := left
    xEnd := left + width
    x := xStart
    while (x <= xEnd) {
        y := centerY + Sin(x / 50) * amplitude
        g := Gui("+AlwaysOnTop -Caption +ToolWindow +E0x20 +E0x08000000")
        g.BackColor := color
        g.Show("x" Round(x - dotSize/2) " y" Round(y - dotSize/2) " w" dotSize " h" dotSize " NoActivate")
        _m1Dots.Push(g)
        x += step
    }
    M1Path_Init()
}
M1Path_MoveCursor(x, y) {
    global cfg, _m1CurDot
    if !_m1CurDot
        return
    curSize := Max(2, cfg["m1_cursorDotSize"])
    try {
        _m1CurDot.Show("x" Round(x - curSize/2) " y" Round(y - curSize/2) " w" curSize " h" curSize " NoActivate")
    } catch {
    }
}

ProcessExistName(name) {
    try {
        for _ in ComObjGet("winmgmts:").ExecQuery("Select * from Win32_Process Where Name='" name "'")
            return true
    } catch {
    }
    return false
}
MoveMouseAbsolute(x, y, speed := 0) {
    try {
        MouseMove x, y, speed
    } catch {
    }
    try {
        DllCall("SetCursorPos", "int", x, "int", y)
    } catch {
    }
}
MoveMouseRelative(dx, dy) {
    try {
        DllCall("mouse_event", "UInt", 0x0001, "Int", dx, "Int", dy, "UInt", 0, "UPtr", 0)
    } catch {
    }
}
LMB_Down() {
    try {
        DllCall("mouse_event", "UInt", 0x0002, "Int", 0, "Int", 0, "UInt", 0, "UPtr", 0)
    } catch {
    }
}
LMB_Up() {
    try {
        DllCall("mouse_event", "UInt", 0x0004, "Int", 0, "Int", 0, "UInt", 0, "UPtr", 0)
    } catch {
    }
}
EnsureLMBHeld(refreshMs := 400) {
    global state
    if (!GetKeyState("LButton","P") || (A_TickCount - state["m1_lastDownRefresh"] >= refreshMs)) {
        LMB_Down()
        state["m1_isDown"] := true
        state["m1_lastDownRefresh"] := A_TickCount
    }
}
StepNameM1(step) {
    global cfg
    switch step {
        case -1: return "Start Delay"
        case 0: return "Prep (" cfg["m1_key1"] "+" cfg["m1_key2"] ")"
        case 1: return "Wavy Move"
        case 2: return "Esc → Reset → Enter"
        case 3: return "Wait"
        default: return "--"
    }
}

ResetTabDefaults(tabName) {
    global cfg, DEFAULT, ui
    switch tabName {
        case "General":
            for k in ["privateServerLink","robloxExe","browserExe","rejoinIntervalMin","preRelaunchSec","postLinkWaitSec","detectTimeoutSec","browserGraceSec","autoRejoinEnabled"]
                cfg[k] := DEFAULT[k]
        case "Eggsterminator":
            for k in ["m1_startDelaySec","m1_tickMs","m1_moveDurationSec","m1_pause1Sec","m1_pause2Sec","m1_loopWaitSec","m1_LeftX","m1_RightX","m1_CenterY","m1_Amplitude","m1_Speed","m1_key1","m1_key1HoldMs","m1_key2","m1_key2HoldMs","m1_postKey2DelayMs","m1_afterPrepKey","m1_keyEsc","m1_keyReset","m1_keyEnter","m1_showBox","m1_boxThickness","m1_boxColor","m1_showPath","m1_pathColor","m1_pathStepPx","m1_pathDotSize","m1_cursorDotColor","m1_cursorDotSize"]
                cfg[k] := DEFAULT[k]
        case "Options":
            for k in ["showCountdownTip","hk_m1","hk_rejoin","hk_overlay"]
                cfg[k] := DEFAULT[k]
        case "Overlay":
            global overlayEnabled, overlayFontSize, overlayTextColor, overlayBackColor, overlayOpacity
            global overlayShowSteps, overlayShowActive, overlayW, overlayH, overlayPadding, overlayRadius, overlayCompact, overlayTheme
            overlayEnabled   := true
            overlayFontSize  := 12
            overlayTextColor := "Lime"
            overlayBackColor := "Black"
            overlayOpacity   := 200
            overlayShowSteps := true
            overlayShowActive:= true
            overlayW := 560
            overlayH := 74
            overlayPadding := 12
            overlayRadius := 14
            overlayCompact := false
            overlayTheme := 0
            SaveOverlaySettings()
            InitOverlay()
    }
    SaveSettings()
    RefreshGuiFromCfg(ui, cfg)
    if (tabName = "Options")
        ApplyHotkeys()
    ToolTip(tabName " reset"), SetTimer(() => ToolTip(), -600)
}

StopAll() {
    StopMacro1()
    M1Box_Hide()
    ToolTip("Stopped")
    SetTimer(() => ToolTip(), -600)
}
